#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(:lparallel) :silent t))

(defpackage :ros.script.collatz.3787876844
  (:use :cl)
  (:import-from #:lparallel
                #:*kernel*
                #:make-kernel
                #:pmap
                #:preduce))
(in-package :ros.script.collatz.3787876844)

(defconstant +1bits+ (1- (ash 1 332)))

(defun rand100 ()
  (random (expt 10 100)))

(defun collatz (value)
  (do ((size 0 (+ size 1))
       (result value (if (= (mod result 2) 1)
                       (+ (* 3 result) 1)
                       (/ result 2))))
    ((<= result 1) size)))

(defun bit-off (x)
  (loop for i below 331
        collect (logand x
                        (logxor +1bits+
                                (ash 1 i)))))

(defun longer-collatz (max-number-and-step base-number depth)
  (when (= depth 0)
    (return-from longer-collatz
      max-number-and-step))

  (let* ((numbers (bit-off base-number))
         (collatz-steps (pmap 'list #'collatz numbers))
         (numbers-and-steps (mapcar #'cons numbers collatz-steps))
         (result (preduce #'(lambda (rhs lhs)
                              (if (> (cdr rhs) (cdr lhs)) rhs lhs))
                          (append (list max-number-and-step)
                                  numbers-and-steps))))
    (when (< (cdr max-number-and-step)
             (cdr result))
      (format t "~S~%" result))
    (loop for n in numbers
          do (setf result (longer-collatz result n (1- depth))))
    result))

(defun main (&rest argv)
  (declare (ignorable argv))
  (let ((*kernel* (make-kernel 4)))
    (make-random-state)
    (longer-collatz (cons 1 0) +1bits+ 2)))
;;; vim: set ft=lisp lisp:
